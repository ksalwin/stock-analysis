#!/usr/bin/env python3
"""
Plot SMA and signals from a file generated by 0_generate_signals.py
"""

import argparse
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Plot SMA and signals from a file generated by 0_generate_signals.py"
    )
    parser.add_argument("--sma-short", type=int, default=20,  help="The short SMA period")
    parser.add_argument("--sma-long",  type=int, default=100, help="The long SMA period")
    parser.add_argument("--from-date", type=str, default=None,
                        help=(  "Plot data starting from this date (inclusive). "
                                "Accepts formats parsable by pandas, e.g. YYYY-MM-DD.")
    )
    parser.add_argument("file", type=str, help="The file to plot (generated by 0_generate_signals.py)")
    return parser.parse_args()


def load_data(file: str) -> pd.DataFrame:
    """
    Load CSV, parse DATETIME, and use it as the index (sorted).

    PARAMETERS
    ----------
    file : str
        The file to load

    RETURNS
    -------
    df : pd.DataFrame
        The loaded dataW
    """
    df = pd.read_csv(file, parse_dates=["DATETIME"])
    df = df.set_index("DATETIME").sort_index()
    return df


def plot_sma_and_signals(df: pd.DataFrame, sma_short: int, sma_long: int, n_xticks: int = 10) -> None:
    """
    Plot PRICE, SMA_short, SMA_long vs. DATETIME and mark Buy/Sell signals if available.

    PARAMETERS
    ----------
    df : pd.DataFrame
        The loaded data
    sma_short : int
        The short SMA period
    sma_long : int
        The long SMA period
    n_xticks : int, optional
        The number of x-axis ticks to show

    RETURNS
    -------
    None
    """
    # Columns
    price_col = "PRICE"
    sma_short_col = f"SMA_{sma_short}"
    sma_long_col  = f"SMA_{sma_long}"

    # Choose a signal column
    sig_col = f"Sig_{sma_short}_{sma_long}"

    # Plot
    fig, ax = plt.subplots()

    # Core series (plot only if columns exist)
    if price_col in df:
        ax.plot(df.index, df[price_col], label="Price")
    if sma_short_col in df:
        ax.plot(df.index, df[sma_short_col], label=f"SMA {sma_short}")
    if sma_long_col in df:
        ax.plot(df.index, df[sma_long_col], label=f"SMA {sma_long}")

    # Signals (supports text Buy/Sell or numeric +/-1)
    if sig_col is not None:
        # Get all signals from the signal column
        sigs = df[sig_col]
        
        # Get buy and sell signals
        # Convert to string and lowercase
        s = sigs.astype("string").str.lower()

        # Get buy and sell signals
        buy_mask = s.eq("buy")
        sell_mask = s.eq("sell")

        # Plot buy signal 
        if buy_mask.any() and price_col in df:
            ax.scatter( df.index[buy_mask],         # is the datetime at the buy signals
                        df.loc[buy_mask, price_col],# is the price at the buy signals
                        marker="^",                 # marker for the buy signals
                        s=60,                       # size of the buy signals
                        edgecolors="black",         # edge color of the buy signals
                        label="Buy",                # label for the buy signals
                        zorder=3)                   # zorder for the buy signals
            # zorder is the order of the plot. The higher the zorder, the on top of the plot.

        # Plot sell signal
        if sell_mask.any() and price_col in df:
            ax.scatter( df.index[sell_mask],         # is the datetime at the sell signals
                        df.loc[sell_mask, price_col],# is the price at the sell signals
                        marker="v",                 # is the marker for the sell signals
                        s=60,                       # is the size of the sell signals
                        edgecolors="black",         # edge color of the sell signals
                        label="Sell",               # is the label for the sell signals
                        zorder=3)                   # is the zorder for the sell signals

    # Set 10 evenly spaced tick labels across the data range
    if len(df.index) > 0:
        # Get the number of ticks to show
        number_of_ticks = min(n_xticks, len(df.index))
        # Get the indices of the ticks
        # linspace(start, stop, num) returns num evenly spaced samples,
        # calculated over the interval [start, stop].
        tick_idx = np.linspace(0, len(df.index) - 1, number_of_ticks).astype(int)
        # Get the locations of the ticks
        tick_locs = df.index[tick_idx]
        # Set the ticks on the x-axis
        ax.set_xticks(tick_locs)
        # Set the tick labels
        # strftime("%Y-%m-%d") formats the datetime as YYYY-MM-DD
        ax.set_xticklabels([d.strftime("%Y-%m-%d") for d in tick_locs], rotation=0)

    # Set labels
    ax.set_xlabel("DATETIME")
    ax.set_ylabel("Price")

    # Set grid
    # True means the grid is shown
    # alpha is the transparency of the grid
    ax.grid(True, alpha=0.3)

    # Set legend. loc="best" means the legend will be placed in the best location.
    ax.legend(loc="best")

    # Set tight layout, which adjusts the padding between the axes and the figure edges.
    plt.tight_layout()

    # Show the plot, which will open a new window.
    plt.show()


def main() -> None:
    args = parse_args()

    df = load_data(args.file)

    # Optionally filter to start from a given date to the newest data
    # getattr(args, "from_date", None) is a way to get the value of the from_date argument
    # if the argument is not provided, it will return None
    if getattr(args, "from_date", None):
        # Convert the from_date argument to a datetime object
        start_dt = pd.to_datetime(args.from_date)
        # Filter the dataframe to only include data from the start date to the newest data
        df = df.loc[df.index >= start_dt]

    plot_sma_and_signals(df, args.sma_short, args.sma_long, n_xticks=10)

if __name__ == "__main__":
    main()